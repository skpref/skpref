{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# We will demonstrate skpref on discrete choice data\n",
    "\n",
    "We wil use the swissmetro dataset available to download on https://transp-or.epfl.ch/pythonbiogeme/examples_swissmetro.html\n",
    "This dataset tracks 470 respondents on which transportation alternative they have taken. There are 3 options in general: train, car and swissmetro.\n",
    "More details on the original use of the dataset can be found here: http://strc.ch/2001/bierlaire1.pdf\n",
    "\n",
    "Since at the moment of writing skpref still didn't have a discrete choice model interfaced, we will reduce the discrete choices to pairwise comparisons.\n",
    "\n",
    "In this notebook we will:\n",
    "\n",
    "* Start by tranforming the original swissmetro dataset into something that skpref can handle.\n",
    "* Fit a logistic regression using the data and the `ClassificationReducer()` method.\n",
    "* Fit a Bradley-Terry model using reduction to pairwise comparisons.\n",
    "* Show how two different aggregation methods for going from a pairwise comparison model to a discrete choice model work.\n",
    "* Show an example using `GridSearchCV()` and how to specify aggregation methods in `GridSearchCV()`\n",
    "* Show some of the evaluation methods that can be applied using skpref"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [],
   "source": [
    "import pandas as pd\n",
    "pd.options.display.max_columns = 999\n",
    "import numpy as np\n",
    "import sys\n",
    "sys.path.insert(0, \"../..\")\n",
    "from skpref.base import ClassificationReducer\n",
    "from skpref.random_utility import BradleyTerry\n",
    "from skpref.task import ChoiceTask\n",
    "from skpref.metrics import f1_score, log_loss, log_loss_compare_with_t_test\n",
    "from skpref.utils import nice_print_results\n",
    "from sklearn.model_selection import train_test_split\n",
    "from sklearn.preprocessing import OneHotEncoder\n",
    "from copy import deepcopy\n",
    "from sklearn.linear_model import LogisticRegression\n",
    "from skpref.model_selection import GridSearchCV"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/html": [
       "<div>\n",
       "<style scoped>\n",
       "    .dataframe tbody tr th:only-of-type {\n",
       "        vertical-align: middle;\n",
       "    }\n",
       "\n",
       "    .dataframe tbody tr th {\n",
       "        vertical-align: top;\n",
       "    }\n",
       "\n",
       "    .dataframe thead th {\n",
       "        text-align: right;\n",
       "    }\n",
       "</style>\n",
       "<table border=\"1\" class=\"dataframe\">\n",
       "  <thead>\n",
       "    <tr style=\"text-align: right;\">\n",
       "      <th></th>\n",
       "      <th>GROUP</th>\n",
       "      <th>SURVEY</th>\n",
       "      <th>SP</th>\n",
       "      <th>ID</th>\n",
       "      <th>PURPOSE</th>\n",
       "      <th>FIRST</th>\n",
       "      <th>TICKET</th>\n",
       "      <th>WHO</th>\n",
       "      <th>LUGGAGE</th>\n",
       "      <th>AGE</th>\n",
       "      <th>MALE</th>\n",
       "      <th>INCOME</th>\n",
       "      <th>GA</th>\n",
       "      <th>ORIGIN</th>\n",
       "      <th>DEST</th>\n",
       "      <th>TRAIN_AV</th>\n",
       "      <th>CAR_AV</th>\n",
       "      <th>SM_AV</th>\n",
       "      <th>TRAIN_TT</th>\n",
       "      <th>TRAIN_CO</th>\n",
       "      <th>TRAIN_HE</th>\n",
       "      <th>SM_TT</th>\n",
       "      <th>SM_CO</th>\n",
       "      <th>SM_HE</th>\n",
       "      <th>SM_SEATS</th>\n",
       "      <th>CAR_TT</th>\n",
       "      <th>CAR_CO</th>\n",
       "      <th>CHOICE</th>\n",
       "    </tr>\n",
       "  </thead>\n",
       "  <tbody>\n",
       "    <tr>\n",
       "      <th>0</th>\n",
       "      <td>2</td>\n",
       "      <td>0</td>\n",
       "      <td>1</td>\n",
       "      <td>1</td>\n",
       "      <td>1</td>\n",
       "      <td>0</td>\n",
       "      <td>1</td>\n",
       "      <td>1</td>\n",
       "      <td>0</td>\n",
       "      <td>3</td>\n",
       "      <td>0</td>\n",
       "      <td>2</td>\n",
       "      <td>0</td>\n",
       "      <td>2</td>\n",
       "      <td>1</td>\n",
       "      <td>1</td>\n",
       "      <td>1</td>\n",
       "      <td>1</td>\n",
       "      <td>112</td>\n",
       "      <td>48</td>\n",
       "      <td>120</td>\n",
       "      <td>63</td>\n",
       "      <td>52</td>\n",
       "      <td>20</td>\n",
       "      <td>0</td>\n",
       "      <td>117</td>\n",
       "      <td>65</td>\n",
       "      <td>2</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>1</th>\n",
       "      <td>2</td>\n",
       "      <td>0</td>\n",
       "      <td>1</td>\n",
       "      <td>1</td>\n",
       "      <td>1</td>\n",
       "      <td>0</td>\n",
       "      <td>1</td>\n",
       "      <td>1</td>\n",
       "      <td>0</td>\n",
       "      <td>3</td>\n",
       "      <td>0</td>\n",
       "      <td>2</td>\n",
       "      <td>0</td>\n",
       "      <td>2</td>\n",
       "      <td>1</td>\n",
       "      <td>1</td>\n",
       "      <td>1</td>\n",
       "      <td>1</td>\n",
       "      <td>103</td>\n",
       "      <td>48</td>\n",
       "      <td>30</td>\n",
       "      <td>60</td>\n",
       "      <td>49</td>\n",
       "      <td>10</td>\n",
       "      <td>0</td>\n",
       "      <td>117</td>\n",
       "      <td>84</td>\n",
       "      <td>2</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>2</th>\n",
       "      <td>2</td>\n",
       "      <td>0</td>\n",
       "      <td>1</td>\n",
       "      <td>1</td>\n",
       "      <td>1</td>\n",
       "      <td>0</td>\n",
       "      <td>1</td>\n",
       "      <td>1</td>\n",
       "      <td>0</td>\n",
       "      <td>3</td>\n",
       "      <td>0</td>\n",
       "      <td>2</td>\n",
       "      <td>0</td>\n",
       "      <td>2</td>\n",
       "      <td>1</td>\n",
       "      <td>1</td>\n",
       "      <td>1</td>\n",
       "      <td>1</td>\n",
       "      <td>130</td>\n",
       "      <td>48</td>\n",
       "      <td>60</td>\n",
       "      <td>67</td>\n",
       "      <td>58</td>\n",
       "      <td>30</td>\n",
       "      <td>0</td>\n",
       "      <td>117</td>\n",
       "      <td>52</td>\n",
       "      <td>2</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>3</th>\n",
       "      <td>2</td>\n",
       "      <td>0</td>\n",
       "      <td>1</td>\n",
       "      <td>1</td>\n",
       "      <td>1</td>\n",
       "      <td>0</td>\n",
       "      <td>1</td>\n",
       "      <td>1</td>\n",
       "      <td>0</td>\n",
       "      <td>3</td>\n",
       "      <td>0</td>\n",
       "      <td>2</td>\n",
       "      <td>0</td>\n",
       "      <td>2</td>\n",
       "      <td>1</td>\n",
       "      <td>1</td>\n",
       "      <td>1</td>\n",
       "      <td>1</td>\n",
       "      <td>103</td>\n",
       "      <td>40</td>\n",
       "      <td>30</td>\n",
       "      <td>63</td>\n",
       "      <td>52</td>\n",
       "      <td>20</td>\n",
       "      <td>0</td>\n",
       "      <td>72</td>\n",
       "      <td>52</td>\n",
       "      <td>2</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>4</th>\n",
       "      <td>2</td>\n",
       "      <td>0</td>\n",
       "      <td>1</td>\n",
       "      <td>1</td>\n",
       "      <td>1</td>\n",
       "      <td>0</td>\n",
       "      <td>1</td>\n",
       "      <td>1</td>\n",
       "      <td>0</td>\n",
       "      <td>3</td>\n",
       "      <td>0</td>\n",
       "      <td>2</td>\n",
       "      <td>0</td>\n",
       "      <td>2</td>\n",
       "      <td>1</td>\n",
       "      <td>1</td>\n",
       "      <td>1</td>\n",
       "      <td>1</td>\n",
       "      <td>130</td>\n",
       "      <td>36</td>\n",
       "      <td>60</td>\n",
       "      <td>63</td>\n",
       "      <td>42</td>\n",
       "      <td>20</td>\n",
       "      <td>0</td>\n",
       "      <td>90</td>\n",
       "      <td>84</td>\n",
       "      <td>2</td>\n",
       "    </tr>\n",
       "  </tbody>\n",
       "</table>\n",
       "</div>"
      ],
      "text/plain": [
       "   GROUP  SURVEY  SP  ID  PURPOSE  FIRST  TICKET  WHO  LUGGAGE  AGE  MALE  \\\n",
       "0      2       0   1   1        1      0       1    1        0    3     0   \n",
       "1      2       0   1   1        1      0       1    1        0    3     0   \n",
       "2      2       0   1   1        1      0       1    1        0    3     0   \n",
       "3      2       0   1   1        1      0       1    1        0    3     0   \n",
       "4      2       0   1   1        1      0       1    1        0    3     0   \n",
       "\n",
       "   INCOME  GA  ORIGIN  DEST  TRAIN_AV  CAR_AV  SM_AV  TRAIN_TT  TRAIN_CO  \\\n",
       "0       2   0       2     1         1       1      1       112        48   \n",
       "1       2   0       2     1         1       1      1       103        48   \n",
       "2       2   0       2     1         1       1      1       130        48   \n",
       "3       2   0       2     1         1       1      1       103        40   \n",
       "4       2   0       2     1         1       1      1       130        36   \n",
       "\n",
       "   TRAIN_HE  SM_TT  SM_CO  SM_HE  SM_SEATS  CAR_TT  CAR_CO  CHOICE  \n",
       "0       120     63     52     20         0     117      65       2  \n",
       "1        30     60     49     10         0     117      84       2  \n",
       "2        60     67     58     30         0     117      52       2  \n",
       "3        30     63     52     20         0      72      52       2  \n",
       "4        60     63     42     20         0      90      84       2  "
      ]
     },
     "execution_count": 2,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "swissmetro = pd.read_csv(\"data/swissmetro.dat\", sep='\\t')\n",
    "swissmetro.head()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Looking at the data we can see that each row represents a choice.\n",
    "The full explanations of variables can be found here: https://transp-or.epfl.ch/pythonbiogeme/examples/swissmetro/swissmetro.pdf"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Changing the format of the tables for skpref\n",
    "\n",
    "\n",
    "1) In this table the availability of alternatives is marked by `TRAIN_AV`, `CAR_AV`, `SM_AV` which indicate with 1 if the alternative is available and 0 otherwise. We need to convert these to a column that contains a list of alternatives for each row.\n",
    "\n",
    "2) The choices are indicated by the `CHOICE` column, which contains 0 for unknown (we will dropping these), 1 for Train, 2 for Swissmetro and 3 for a Car usage. We need to name these explicitly. We could just create a list of alternatives called 1,2,3 in step 1 which would bypass step 2, however, we prefer the clarity of having the alternatives named explicitly.\n",
    "\n",
    "# Using only a subset of the available features\n",
    "Under normal circumstances we would use one-hot encoding on a lot of the binary features before training a serious model, however, to make the demo simple, we will only use the travel time and cost features. Users can of course do whatever feature transformations they like before fitting a model.\n",
    "To build a classifier based on travel time and costs, we first need to split some columns from the swissmetro dataset into a secondary table."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/html": [
       "<div>\n",
       "<style scoped>\n",
       "    .dataframe tbody tr th:only-of-type {\n",
       "        vertical-align: middle;\n",
       "    }\n",
       "\n",
       "    .dataframe tbody tr th {\n",
       "        vertical-align: top;\n",
       "    }\n",
       "\n",
       "    .dataframe thead th {\n",
       "        text-align: right;\n",
       "    }\n",
       "</style>\n",
       "<table border=\"1\" class=\"dataframe\">\n",
       "  <thead>\n",
       "    <tr style=\"text-align: right;\">\n",
       "      <th></th>\n",
       "      <th>merge_index</th>\n",
       "      <th>Travel Time</th>\n",
       "      <th>Cost</th>\n",
       "      <th>alternative</th>\n",
       "    </tr>\n",
       "  </thead>\n",
       "  <tbody>\n",
       "    <tr>\n",
       "      <th>0</th>\n",
       "      <td>0</td>\n",
       "      <td>112</td>\n",
       "      <td>48</td>\n",
       "      <td>Train</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>0</th>\n",
       "      <td>0</td>\n",
       "      <td>63</td>\n",
       "      <td>52</td>\n",
       "      <td>Swiss Metro</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>0</th>\n",
       "      <td>0</td>\n",
       "      <td>117</td>\n",
       "      <td>65</td>\n",
       "      <td>Car</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>1</th>\n",
       "      <td>1</td>\n",
       "      <td>103</td>\n",
       "      <td>48</td>\n",
       "      <td>Train</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>1</th>\n",
       "      <td>1</td>\n",
       "      <td>60</td>\n",
       "      <td>49</td>\n",
       "      <td>Swiss Metro</td>\n",
       "    </tr>\n",
       "  </tbody>\n",
       "</table>\n",
       "</div>"
      ],
      "text/plain": [
       "   merge_index  Travel Time  Cost  alternative\n",
       "0            0          112    48        Train\n",
       "0            0           63    52  Swiss Metro\n",
       "0            0          117    65          Car\n",
       "1            1          103    48        Train\n",
       "1            1           60    49  Swiss Metro"
      ]
     },
     "execution_count": 3,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "train_vals = swissmetro[['TRAIN_TT', 'TRAIN_CO']].copy()\n",
    "train_vals.columns = ['Travel Time', 'Cost']\n",
    "train_vals.reset_index(inplace=True)\n",
    "train_vals['alternative'] = 'Train'\n",
    "swissmetro_vals = swissmetro[['SM_TT', 'SM_CO']].copy()\n",
    "swissmetro_vals.columns = ['Travel Time', 'Cost']\n",
    "swissmetro_vals.reset_index(inplace=True)\n",
    "swissmetro_vals['alternative'] = 'Swiss Metro'\n",
    "car_vals = swissmetro[['CAR_TT', 'CAR_CO']].copy()\n",
    "car_vals.columns = ['Travel Time', 'Cost']\n",
    "car_vals.reset_index(inplace=True)\n",
    "car_vals['alternative'] = 'Car'\n",
    "dummy_secondary_table = (\n",
    "    train_vals.append(swissmetro_vals.append(car_vals))\n",
    ").sort_values('index')\n",
    "dummy_secondary_table.rename(columns={'index': 'merge_index'}, inplace=True)\n",
    "dummy_secondary_table.head()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/html": [
       "<div>\n",
       "<style scoped>\n",
       "    .dataframe tbody tr th:only-of-type {\n",
       "        vertical-align: middle;\n",
       "    }\n",
       "\n",
       "    .dataframe tbody tr th {\n",
       "        vertical-align: top;\n",
       "    }\n",
       "\n",
       "    .dataframe thead th {\n",
       "        text-align: right;\n",
       "    }\n",
       "</style>\n",
       "<table border=\"1\" class=\"dataframe\">\n",
       "  <thead>\n",
       "    <tr style=\"text-align: right;\">\n",
       "      <th></th>\n",
       "      <th>alternatives</th>\n",
       "      <th>chosen</th>\n",
       "      <th>merge_index</th>\n",
       "    </tr>\n",
       "  </thead>\n",
       "  <tbody>\n",
       "    <tr>\n",
       "      <th>0</th>\n",
       "      <td>[Train, Car, Swiss Metro]</td>\n",
       "      <td>Swiss Metro</td>\n",
       "      <td>0</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>1</th>\n",
       "      <td>[Train, Car, Swiss Metro]</td>\n",
       "      <td>Swiss Metro</td>\n",
       "      <td>1</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>2</th>\n",
       "      <td>[Train, Car, Swiss Metro]</td>\n",
       "      <td>Swiss Metro</td>\n",
       "      <td>2</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>3</th>\n",
       "      <td>[Train, Car, Swiss Metro]</td>\n",
       "      <td>Swiss Metro</td>\n",
       "      <td>3</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>4</th>\n",
       "      <td>[Train, Car, Swiss Metro]</td>\n",
       "      <td>Swiss Metro</td>\n",
       "      <td>4</td>\n",
       "    </tr>\n",
       "  </tbody>\n",
       "</table>\n",
       "</div>"
      ],
      "text/plain": [
       "                alternatives       chosen  merge_index\n",
       "0  [Train, Car, Swiss Metro]  Swiss Metro            0\n",
       "1  [Train, Car, Swiss Metro]  Swiss Metro            1\n",
       "2  [Train, Car, Swiss Metro]  Swiss Metro            2\n",
       "3  [Train, Car, Swiss Metro]  Swiss Metro            3\n",
       "4  [Train, Car, Swiss Metro]  Swiss Metro            4"
      ]
     },
     "execution_count": 4,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "binary_concats = (swissmetro.TRAIN_AV.astype(str) + \n",
    "                  swissmetro.CAR_AV.astype(str)  + \n",
    "                  swissmetro.SM_AV.astype(str)\n",
    "                 )\n",
    "\n",
    "alts = []\n",
    "for i in binary_concats.values:\n",
    "    if i == '111':\n",
    "        alts.append(['Train', 'Car', 'Swiss Metro'])\n",
    "    elif i == '100':\n",
    "        alts.append(['Train'])\n",
    "    elif i == '000':\n",
    "        alts.append(['None'])\n",
    "    elif i == '010':\n",
    "        alts.append(['Car'])\n",
    "    elif i == '001':\n",
    "        alts.append(['Swiss Metro'])\n",
    "    elif i == '101':\n",
    "        alts.append(['Train', 'Swiss Metro'])\n",
    "    elif i == '110':\n",
    "        alts.append(['Train', 'Car'])\n",
    "    elif i == '011':\n",
    "        alts.append(['Car', 'Swiss Metro'])\n",
    "        \n",
    "swissmetro['alternatives'] = alts\n",
    "        \n",
    "swissmetro['chosen'] = np.where(swissmetro.CHOICE.values==1, 'Train',\n",
    "                       np.where(swissmetro.CHOICE.values==2, 'Swiss Metro',\n",
    "                       np.where(swissmetro.CHOICE.values==3, 'Car',\n",
    "                                'unknown')))\n",
    "swissmetro = swissmetro[swissmetro.CHOICE != 0].copy()\n",
    "swissmetro = swissmetro.reset_index()[['alternatives', 'chosen', 'index']]\n",
    "swissmetro.rename(columns={'index': 'merge_index'}, inplace=True)\n",
    "swissmetro.head()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([list(['Train', 'Car', 'Swiss Metro']),\n",
       "       list(['Train', 'Car', 'Swiss Metro']),\n",
       "       list(['Train', 'Car', 'Swiss Metro']), ...,\n",
       "       list(['Train', 'Car', 'Swiss Metro']),\n",
       "       list(['Train', 'Car', 'Swiss Metro']),\n",
       "       list(['Train', 'Car', 'Swiss Metro'])], dtype=object)"
      ]
     },
     "execution_count": 5,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "swissmetro.alternatives.values"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Fit a logistic regression\n",
    "This will fit a logistic regression that uses only travel time and cost as covariates, with the following formulation for observation $i$ and $a \\in \\{\\text{Car, Train, Swiss Metro}\\}$:\n",
    "$$P(Y_i = a) = logit(\\lambda_{\\text{a}} + \\beta_1 (\\text{Travel Time})_a + \\beta_2(\\text{Cost})_a)$$ \n",
    "\n",
    "Below we showcase how the ChoiceTask wrapper can deal with creating this reduction"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [],
   "source": [
    "train, test = train_test_split(swissmetro, random_state=1, test_size=0.1)\n",
    "\n",
    "swiss_metro_train = ChoiceTask(train, 'alternatives', 'chosen',\n",
    "                               features_to_use=['Travel Time', 'Cost'],\n",
    "                               secondary_table=dummy_secondary_table,\n",
    "                               secondary_to_primary_link={\n",
    "                                   'merge_index': 'merge_index',\n",
    "                                   'alternative': 'alternatives'\n",
    "                               }\n",
    "                              )\n",
    "\n",
    "swiss_metro_test = ChoiceTask(test, 'alternatives', 'chosen',\n",
    "                              features_to_use=['Travel Time', 'Cost'],\n",
    "                              secondary_table=dummy_secondary_table,\n",
    "                              secondary_to_primary_link={\n",
    "                                   'merge_index': 'merge_index',\n",
    "                                   'alternative': 'alternatives'\n",
    "                               }\n",
    "                             )"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {},
   "outputs": [],
   "source": [
    "my_log_red = ClassificationReducer(LogisticRegression(solver='lbfgs'))\n",
    "my_log_red.fit_task(swiss_metro_train)\n",
    "log_reg_preds = my_log_red.predict_proba_task(swiss_metro_test,\n",
    "                                      ['Swiss Metro','Train', 'Car'])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Swiss Metro  [0.49 0.56 0.4  ... 0.47 0.35 0.51]\n",
      "Train        [0.3  0.45 0.17 ... 0.36 0.29 0.26]\n",
      "Car          [0.33 0.   0.2  ... 0.45 0.36 0.25]\n"
     ]
    }
   ],
   "source": [
    "nice_print_results(log_reg_preds)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "['Swiss Metro' 'Swiss Metro' 'Swiss Metro' 'Swiss Metro' 'Swiss Metro']\n",
      "[array(['Car', 'Train'], dtype='<U11') array(['Train'], dtype='<U11')\n",
      " array(['Car', 'Train'], dtype='<U11')\n",
      " array(['Car', 'Train'], dtype='<U11')\n",
      " array(['Car', 'Train'], dtype='<U11')]\n"
     ]
    }
   ],
   "source": [
    "outocme_preds = my_log_red.predict_task(swiss_metro_test)\n",
    "print(outocme_preds.top_input_data[:5])\n",
    "print(outocme_preds.boot_input_data[:5])"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Fit a Bradley-Terry model without covariates\n",
    "Here we reduce the discrete choice problem to pairwise comparisons and fit a Bradley-Terry model.\n",
    "\n",
    "The way these observations are broken down are such that when alternative $a$ is chosen from the set $A$ then an observation is expressed in a way that we say the chosen alternative was preferred to all not-chosen alternatives, $a \\succ j \\forall j \\in A \\setminus a$. This transforms a table that looks like this:\n",
    "\n",
    "|Decision| Alternatives | Choice |\n",
    "| --- | --- | --- |\n",
    "| 1 | {a, b, c} | a |\n",
    "| 2 | {b, c} | c |\n",
    "\n",
    "into a table that looks like this:\n",
    "\n",
    "|Decision | Alternatives | Choice |\n",
    "| --- | --- | --- |\n",
    "| 1 | {a, b} | a |\n",
    "| 1 | {a, c} | a |\n",
    "| 2 | {b, c} | c |\n",
    "\n",
    "A pariwise comparison model such as Bradley-Terry can be trained on the second table. Perhaps to make it similar to the pairwise comparison example we can also express the above table in the more familiar format:\n",
    "\n",
    "|Decision | Alternative 1 | Alternative 2 | Alternative 1 is chosen |\n",
    "| --- | --- | --- | --- |\n",
    "| 1 | a | b | 1 |\n",
    "| 1 | a | c | 1 |\n",
    "| 2 | b | c | 0 |\n",
    "\n",
    "\n",
    "and fit the Bradley-Terry model to learn the latent strength parameters for each alternative (e.g. $\\lambda_a$ for alternative $a$):\n",
    "\n",
    "$$P(\\text{Alternative 1 is chosen})_i = \\frac{e^{\\lambda_{\\text{Alternative 1}_i}}}{e^{\\lambda_{\\text{Alternative 1}_i}} + e^{\\lambda_{\\text{Alternative 2}_i}}}$$\n",
    "\n",
    "We can see that the Bradley-Terry probabilities begin to take into account the other alternatives that are offered to the decision makers, in contrast with logistic regression, which assumes that the probability of taking Swissmetro is the same whether a decision maker has a car as an alternative, a train or both. Once the Bradley-Terry model is trained, predictions have to be aggregated to discrete choice. In this section we showcase two aggregation methods one we call the Luce method the other the independent transitive method.\n",
    "\n",
    "## The Luce method (the default setting when aggregating a Bradley-Terry model)\n",
    "For alternatives $\\{a, b, c\\}$ when we fit the Bradley-Terry model we learn the function $f(a), f(b), f(c)$ which include their strength parameters and potentially some covariates, in the econometrics literature this would be known as finding out the utility of each alternative. In the simplest case the utility equations only contain the strength parameters of the alternatives (e.g. $\\lambda_a$ for alternative $a$). The Luce aggregation method would predict the probability of choosing $a$ from $\\{a, b, c\\}$ as:\n",
    "$$\\frac{e^{f(a)}}{e^{f(a)}+ e^{f(b)} + e^{f(c)}}$$.\n",
    "\n",
    "## The independent transitive aggregation method\n",
    "Let's denote the probability of chosing $a$ from $\\{a, b, c\\}$ as $P(a\\succ \\{a,b,c\\})$.\n",
    "Suppose that we have a probabilistic pairwise comparison predictor (such as Bradley-Terry) that can provide us with the probability of preferring one over any two alternatives $P(i \\succ \\{i, j\\}) \\forall i,j \\in \\{a, b, c\\}$.\n",
    "\n",
    "The independent transitive method stems from the following logic:\n",
    "\n",
    "1. For $a$ to be chosen from $\\{a, b, c\\}$, $a$ would have to be preferred to $b$ and $c$, that is $a\\succ\\{a,b\\} \\cap a\\succ\\{a,c\\}$\n",
    "2. Assuming that $a$ being preferred to $c$ is independent from $a$ being preferred to $b$, the probability of $a$ being preferred to $b$ and $c$ is: $P(a\\succ\\{a,b\\} \\cap a\\succ\\{a,c\\}) = P(a\\succ\\{a,b\\})P(a\\succ\\{a,c\\})$\n",
    "3. In this three-alternative aggregation example, only 2 other things can happen in addition to $a$ being chosen, $b$ can be chosen or $c$ can be chosen. Each of which can be expressed as we have expressed the probability of $a$ being chosen in bullet 2.\n",
    "4. By dividing the probability of $a$ being chosen by all the three different possible outcomes ($a$ is chosen, $b$ is chosen or $c$ is chosen), we arrive to the final equation of the probability that $a$ is chosen from $\\{a, b, c\\}$:\n",
    "\n",
    "$$\\frac{P(a\\succ\\{a,b\\})P(a\\succ\\{a,c\\})}{P(a\\succ\\{a,b\\})P(a\\succ\\{a,c\\}) + P(b\\succ\\{a,b\\})P(b\\succ\\{b,c\\}) + P(c\\succ\\{a,c\\})P(c\\succ\\{b,c\\})}$$ "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Fit a Bradley Terry model with no features\n",
    "swiss_metro_train_BT = ChoiceTask(train.drop('merge_index', axis=1), \n",
    "                                  'alternatives',\n",
    "                                  'chosen', features_to_use=None)\n",
    "\n",
    "swiss_metro_test_BT = ChoiceTask(test.drop('merge_index', axis=1), \n",
    "                                 'alternatives',\n",
    "                                 'chosen', features_to_use=None)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "metadata": {},
   "outputs": [],
   "source": [
    "my_BT_red = BradleyTerry(method='BFGS', alpha=1e-5)\n",
    "my_BT_red.fit_task(swiss_metro_train_BT)\n",
    "preds = my_BT_red.predict_proba_task(swiss_metro_test_BT,\n",
    "                                     ['Swiss Metro','Train', 'Car'])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Swiss Metro  [0.55 0.83 0.55 ... 0.55 0.55 0.55]\n",
      "Train        [0.11 0.17 0.11 ... 0.11 0.11 0.11]\n",
      "Car          [0.35 0.   0.35 ... 0.35 0.35 0.35]\n"
     ]
    }
   ],
   "source": [
    "nice_print_results(preds)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "['Swiss Metro' 'Swiss Metro' 'Swiss Metro' 'Swiss Metro' 'Swiss Metro']\n",
      "[array(['Car', 'Train'], dtype='<U11') array(['Train'], dtype='<U11')\n",
      " array(['Car', 'Train'], dtype='<U11')\n",
      " array(['Car', 'Train'], dtype='<U11')\n",
      " array(['Car', 'Train'], dtype='<U11')]\n"
     ]
    }
   ],
   "source": [
    "choice_preds = my_BT_red.predict_task(swiss_metro_test_BT)\n",
    "print(choice_preds.top_input_data[:5])\n",
    "print(choice_preds.boot_input_data[:5])"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Fitting a Bradley-Terry model with covariates\n",
    "\n",
    "We now fit a Bradley-Terry model using the Travel Time and Cost covariates so that the equation above becomes:\n",
    "$$P(\\text{Alternative 1 is chosen})_i = \\frac{e^{\\lambda_{\\text{Alternative 1}_i}+ \\beta_1 \\text{(Travel Time)}_i + \\beta_2 \\text{Cost}_i}}{e^{\\lambda_{\\text{Alternative 1}_i} + \\beta_1 \\text{(Travel Time)}_i + \\beta_2 \\text{Cost}_i} + e^{\\lambda_{\\text{Alternative 2}_i}+ \\beta_1 \\text{(Travel Time)}_i + \\beta_2 \\text{Cost}_i}}$$"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "metadata": {
    "scrolled": true
   },
   "outputs": [],
   "source": [
    "# Fit a Bradley Terry model with features\n",
    "# Reducing training set because on my PC this gives a memory error\n",
    "swiss_metro_train_BT_feats = ChoiceTask(\n",
    "    train.sample(frac=0.5), 'alternatives', 'chosen',\n",
    "    secondary_table=dummy_secondary_table,\n",
    "    secondary_to_primary_link={\n",
    "        'merge_index': 'merge_index',\n",
    "        'alternative': 'alternatives'\n",
    "    },\n",
    "    features_to_use=['Travel Time', 'Cost'])\n",
    "\n",
    "swiss_metro_test = ChoiceTask(test, 'alternatives', 'chosen',\n",
    "                              features_to_use=['Travel Time', 'Cost'],\n",
    "                              secondary_table=dummy_secondary_table,\n",
    "                              secondary_to_primary_link={\n",
    "                                   'merge_index': 'merge_index',\n",
    "                                   'alternative': 'alternatives'\n",
    "                               }\n",
    "                             )\n",
    "\n",
    "my_BT_red_feats = BradleyTerry(method='BFGS', alpha=1e-5)\n",
    "my_BT_red_feats.fit_task(swiss_metro_train_BT_feats)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "metadata": {},
   "outputs": [],
   "source": [
    "swiss_metro_test = ChoiceTask(test, 'alternatives', 'chosen',\n",
    "                              features_to_use=['Travel Time', 'Cost'],\n",
    "                              secondary_table=dummy_secondary_table,\n",
    "                              secondary_to_primary_link={\n",
    "                                   'merge_index': 'merge_index',\n",
    "                                   'alternative': 'alternatives'\n",
    "                               }\n",
    "                             )\n",
    "preds = my_BT_red_feats.predict_proba_task(swiss_metro_test,\n",
    "                                      ['Swiss Metro','Train', 'Car'])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array(['Swiss Metro', 'Swiss Metro', 'Swiss Metro', ..., 'Car', 'Car',\n",
       "       'Swiss Metro'], dtype=object)"
      ]
     },
     "execution_count": 16,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "my_BT_red_feats.predict_task(swiss_metro_test).top_input_data"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Swiss Metro  [0.56 0.76 0.66 ... 0.4  0.37 0.68]\n",
      "Train        [0.12 0.24 0.09 ... 0.13 0.14 0.1 ]\n",
      "Car          [0.32 0.   0.25 ... 0.47 0.48 0.22]\n"
     ]
    }
   ],
   "source": [
    "nice_print_results(preds)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Swiss Metro  [0.62 0.76 0.73 ... 0.43 0.39 0.76]\n",
      "Train        [0.06 0.24 0.03 ... 0.06 0.08 0.05]\n",
      "Car          [0.32 0.   0.23 ... 0.51 0.53 0.19]\n"
     ]
    }
   ],
   "source": [
    "ind_trans_preds = my_BT_red_feats.predict_proba_task(swiss_metro_test,\n",
    "                                   ['Swiss Metro','Train', 'Car'],\n",
    "                                   aggregation_method='independent transitive')\n",
    "nice_print_results(ind_trans_preds)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "metadata": {},
   "outputs": [],
   "source": [
    "preds_outcome_ind_trans = my_BT_red_feats.predict_task(swiss_metro_test,\n",
    "                             aggregation_method='independent transitive')\n",
    "preds_outcome_Luce = my_BT_red_feats.predict_task(swiss_metro_test)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/html": [
       "<div>\n",
       "<style scoped>\n",
       "    .dataframe tbody tr th:only-of-type {\n",
       "        vertical-align: middle;\n",
       "    }\n",
       "\n",
       "    .dataframe tbody tr th {\n",
       "        vertical-align: top;\n",
       "    }\n",
       "\n",
       "    .dataframe thead th {\n",
       "        text-align: right;\n",
       "    }\n",
       "</style>\n",
       "<table border=\"1\" class=\"dataframe\">\n",
       "  <thead>\n",
       "    <tr style=\"text-align: right;\">\n",
       "      <th></th>\n",
       "      <th>merge_index</th>\n",
       "      <th>Travel Time</th>\n",
       "      <th>Cost</th>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>alternative</th>\n",
       "      <th></th>\n",
       "      <th></th>\n",
       "      <th></th>\n",
       "    </tr>\n",
       "  </thead>\n",
       "  <tbody>\n",
       "    <tr>\n",
       "      <th>Car</th>\n",
       "      <td>5363.5</td>\n",
       "      <td>123.795209</td>\n",
       "      <td>78.742077</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>Swiss Metro</th>\n",
       "      <td>5363.5</td>\n",
       "      <td>87.466350</td>\n",
       "      <td>670.340697</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>Train</th>\n",
       "      <td>5363.5</td>\n",
       "      <td>166.626025</td>\n",
       "      <td>514.335477</td>\n",
       "    </tr>\n",
       "  </tbody>\n",
       "</table>\n",
       "</div>"
      ],
      "text/plain": [
       "             merge_index  Travel Time        Cost\n",
       "alternative                                      \n",
       "Car               5363.5   123.795209   78.742077\n",
       "Swiss Metro       5363.5    87.466350  670.340697\n",
       "Train             5363.5   166.626025  514.335477"
      ]
     },
     "execution_count": 20,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "dummy_secondary_table.groupby('alternative').mean()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 21,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "\n",
      "Number of Parameters                                                      5\n",
      "Number of Observations                                                 8874\n",
      "Null Log-Likelihood                                             -6150.98808\n",
      "Fitted Log-Likelihood                                          -4734.273238\n",
      "Rho-Squared                                                        0.230323\n",
      "Rho-Bar-Squared                                                     0.22951\n",
      "Estimation Message        Desired error not necessarily achieved due to ...\n",
      "dtype: object\n",
      "==============================\n",
      "             parameters     std_err    t_stats       p_values  robust_std_err  \\\n",
      "Cost           0.000239    0.000030   7.927323   2.239209e-15        0.000031   \n",
      "Travel Time   -0.011717    0.000539 -21.740280  8.537672e-105        0.001020   \n",
      "Car            0.347770  129.099448   0.002694   9.978507e-01             NaN   \n",
      "Swiss Metro    0.136513  129.099449   0.001057   9.991563e-01             NaN   \n",
      "Train         -0.484282  129.099449  -0.003751   9.970070e-01             NaN   \n",
      "\n",
      "             robust_t_stats  robust_p_values  \n",
      "Cost               7.603109     2.891001e-14  \n",
      "Travel Time      -11.491478     1.455993e-30  \n",
      "Car                     NaN              NaN  \n",
      "Swiss Metro             NaN              NaN  \n",
      "Train                   NaN              NaN  \n"
     ]
    }
   ],
   "source": [
    "my_BT_red_feats.bt_with_feats.print_summaries()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Fit Bradley-Terry model with GridSearch\n",
    "The models we have fitted above also have hyperparameters, such as the method of gradient descent or regularisation. To  optimise the hyperparameter selection, we can use `GridSearchCV()`. `GridSearchCV()` tries out a series of hyperparameter combinations and runs a k-fold cross-validation on an accuracy metric determined by the user to check which ones have performed best.\n",
    "\n",
    "In this section we will show how aggregation works with GridSearch, it is possible to just add `aggregation_method` in the `predict_proba_task` and the ouptuts work as expected. Note in this example we have chosen a very different alpha to the models above so that there is some slight difference in the ouptuts to two decimal places, so that we can see that different parameters were learned."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 22,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "The model with the best parameters was:\n",
      "BradleyTerry(alpha=100, method='BFGS')\n",
      "With a score of -0.5356138170005121\n",
      "All the trials results summarised in descending score\n",
      "   alpha method  mean_test_score\n",
      "0    100   BFGS        -0.535614\n",
      "1   1000   BFGS        -0.545660\n"
     ]
    }
   ],
   "source": [
    "to_tune = {'alpha': [100,1000], 'method': ['BFGS']}\n",
    "gs_bt = GridSearchCV(BradleyTerry(), to_tune,  cv=3, scoring='neg_log_loss')\n",
    "gs_bt.fit_task(swiss_metro_train_BT_feats)\n",
    "gs_bt.inspect_results()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 23,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Swiss Metro  [0.63 0.74 0.75 ... 0.42 0.38 0.78]\n",
      "Train        [0.07 0.26 0.04 ... 0.08 0.09 0.06]\n",
      "Car          [0.3  0.   0.22 ... 0.5  0.53 0.17]\n"
     ]
    }
   ],
   "source": [
    "nice_print_results(gs_bt.predict_proba_task(\n",
    "    swiss_metro_test,['Swiss Metro','Train', 'Car'],\n",
    "    aggregation_method='independent transitive'))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 24,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "\n",
      "Number of Parameters                                                      5\n",
      "Number of Observations                                                 8874\n",
      "Null Log-Likelihood                                             -6150.98808\n",
      "Fitted Log-Likelihood                                          -4765.068522\n",
      "Rho-Squared                                                        0.225317\n",
      "Rho-Bar-Squared                                                    0.224504\n",
      "Estimation Message        Desired error not necessarily achieved due to ...\n",
      "dtype: object\n",
      "==============================\n",
      "             parameters   std_err    t_stats       p_values  robust_std_err  \\\n",
      "Cost           0.000234  0.000030   7.813176   5.576466e-15        0.000030   \n",
      "Travel Time   -0.012479  0.000513 -24.303950  1.780605e-130        0.000912   \n",
      "Car            0.302333  0.045697   6.616091   3.688214e-11             NaN   \n",
      "Swiss Metro    0.090960  0.047996   1.895185   5.806786e-02             NaN   \n",
      "Train         -0.393294  0.048153  -8.167619   3.145352e-16             NaN   \n",
      "\n",
      "             robust_t_stats  robust_p_values  \n",
      "Cost               7.711453     1.243931e-14  \n",
      "Travel Time      -13.690371     1.159165e-42  \n",
      "Car                     NaN              NaN  \n",
      "Swiss Metro             NaN              NaN  \n",
      "Train                   NaN              NaN  \n"
     ]
    }
   ],
   "source": [
    "gs_bt.best_estimator_.bt_with_feats.print_summaries()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Evaluation methods\n",
    "In this section we show some of the evaluation methods available in skpref, specifically how to use `log_loss` and `log_loss_compare_with_t_test`. Please see the documentation for more details on how these work."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 25,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "The F1 score of the Luce aggregation was  0.595\n",
      "The F1 score of the generic aggregation was 0.595\n"
     ]
    }
   ],
   "source": [
    "print(f\"The F1 score of the Luce aggregation was \\\n",
    "{f1_score(swiss_metro_test.subset_vec, preds_outcome_Luce): .3}\")\n",
    "print(f\"The F1 score of the generic aggregation was \\\n",
    "{f1_score(swiss_metro_test.subset_vec, preds_outcome_ind_trans):.3}\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 26,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "The log loss for each alternative in the Logistic Regression reduction was \n",
      " {'Swiss Metro_log_loss': 0.73, 'Train_log_loss': 0.44, 'Car_log_loss': 0.57}\n",
      "The log loss for each alternative in the Luce aggregation was \n",
      " {'Swiss Metro_log_loss': 0.7, 'Train_log_loss': 0.38, 'Car_log_loss': 0.52}\n",
      "The log loss for each alternative in the generic aggregation was \n",
      " {'Swiss Metro_log_loss': 0.71, 'Train_log_loss': 0.39, 'Car_log_loss': 0.52}\n",
      "The log loss for each alternative assigning random probability was \n",
      " {'Swiss Metro_log_loss': 0.8, 'Train_log_loss': 0.5, 'Car_log_loss': 0.61}\n"
     ]
    }
   ],
   "source": [
    "random_probs = {\n",
    "    'Swiss Metro': np.ones(len(test)) * (1/3),\n",
    "    'Train': np.ones(len(test)) * (1/3),\n",
    "    'Car': np.ones(len(test)) * (1/3)\n",
    "}\n",
    "log_reg_preds\n",
    "print(f\"The log loss for each alternative in the Logistic Regression reduction was \\n \\\n",
    "{log_loss(swiss_metro_test.subset_vec, log_reg_preds)}\")\n",
    "print(f\"The log loss for each alternative in the Luce aggregation was \\n \\\n",
    "{log_loss(swiss_metro_test.subset_vec, preds)}\")\n",
    "print(f\"The log loss for each alternative in the generic aggregation was \\n \\\n",
    "{log_loss(swiss_metro_test.subset_vec, ind_trans_preds)}\")\n",
    "print(f\"The log loss for each alternative assigning random probability was \\n \\\n",
    "{log_loss(swiss_metro_test.subset_vec, random_probs)}\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 27,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "The t-test for H0: Luce aggregation = Generic aggregation {'Swiss Metro': 0.05, 'Train': 0.28, 'Car': 0.22}\n",
      "The t-test for H0: Generic aggregation = random probability {'Swiss Metro': 0.0, 'Train': 0.0, 'Car': 0.0}\n",
      "The t-test for H0: Generic aggregation = Logistic Regression {'Swiss Metro': 0.14, 'Train': 0.0, 'Car': 0.0}\n",
      "The t-test for H0: Generic aggregation = random probability {'Swiss Metro': 0.0, 'Train': 0.0, 'Car': 0.0}\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "../..\\skpref\\metrics\\_classification.py:254: RuntimeWarning: divide by zero encountered in log\n",
      "  logged = np.log(predicted1[_alternative])\n",
      "../..\\skpref\\metrics\\_classification.py:258: RuntimeWarning: invalid value encountered in multiply\n",
      "  np.nan_to_num(logged * binarized_outcome) +\n",
      "../..\\skpref\\metrics\\_classification.py:261: RuntimeWarning: divide by zero encountered in log\n",
      "  logged2 = np.log(predicted2[_alternative])\n",
      "../..\\skpref\\metrics\\_classification.py:265: RuntimeWarning: invalid value encountered in multiply\n",
      "  np.nan_to_num(logged2 * binarized_outcome) +\n"
     ]
    }
   ],
   "source": [
    "print(f\"The t-test for H0: Luce aggregation = Generic aggregation \\\n",
    "{log_loss_compare_with_t_test(swiss_metro_test.subset_vec, preds, ind_trans_preds)}\")\n",
    "print(f\"The t-test for H0: Generic aggregation = random probability \\\n",
    "{log_loss_compare_with_t_test(swiss_metro_test.subset_vec, ind_trans_preds, random_probs)}\")\n",
    "print(f\"The t-test for H0: Generic aggregation = Logistic Regression \\\n",
    "{log_loss_compare_with_t_test(swiss_metro_test.subset_vec, ind_trans_preds, log_reg_preds)}\")\n",
    "print(f\"The t-test for H0: Generic aggregation = random probability \\\n",
    "{log_loss_compare_with_t_test(swiss_metro_test.subset_vec, ind_trans_preds, random_probs)}\")"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.11"
  },
  "varInspector": {
   "cols": {
    "lenName": 16,
    "lenType": 16,
    "lenVar": 40
   },
   "kernels_config": {
    "python": {
     "delete_cmd_postfix": "",
     "delete_cmd_prefix": "del ",
     "library": "var_list.py",
     "varRefreshCmd": "print(var_dic_list())"
    },
    "r": {
     "delete_cmd_postfix": ") ",
     "delete_cmd_prefix": "rm(",
     "library": "var_list.r",
     "varRefreshCmd": "cat(var_dic_list()) "
    }
   },
   "types_to_exclude": [
    "module",
    "function",
    "builtin_function_or_method",
    "instance",
    "_Feature"
   ],
   "window_display": false
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
